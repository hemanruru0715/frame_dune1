import { getFarcasterChannelsByParticipant, getFarcasterFollowers, getFarcasterFollowings, getFarcasterUserCasts, getFarcasterUserDetails, init, } from "../..";
import { Features, } from "../../types";
import { config } from "dotenv";
import { decodeFrameActionPayloadFromRequest } from "../../utils/decodeFrameActionPayloadFromRequest";
import { Message } from "@farcaster/core";
import { config as configEnv } from "../../config";
config();
/**
 *
 * @param input
 * @returns
 */
export const farcasterDataFramesjsMiddleware = (input) => {
    const { apiKey, features } = input !== null && input !== void 0 ? input : {};
    // If an apiKey is provided, initialize the SDK with custom API key
    if (apiKey && !(configEnv === null || configEnv === void 0 ? void 0 : configEnv.authKey))
        init(apiKey);
    return async (ctx, next) => {
        var _a;
        let farcasterRes = {};
        // frame message is available only if the request is a POST request
        if (ctx.request.method !== "POST") {
            return next();
        }
        // body must be a JSON object
        const payload = await decodeFrameActionPayloadFromRequest(ctx.request);
        // for initial frame, directly return the Frame
        if (!payload) {
            return next();
        }
        const decodedMessage = Message.decode(Buffer.from(payload.trustedData.messageBytes, "hex"));
        const { fid } = (_a = decodedMessage === null || decodedMessage === void 0 ? void 0 : decodedMessage.data) !== null && _a !== void 0 ? _a : {};
        try {
            const [userDetailsResponse, farcasterFollowingsResponse, farcasterFollowersResponse, farcasterChannelsResponse, farcasterCastsResponse,] = await Promise.all([
                features.includes(Features.USER_DETAILS)
                    ? getFarcasterUserDetails({
                        fid,
                    })
                    : Promise.resolve(undefined),
                features.includes(Features.FARCASTER_FOLLOWINGS)
                    ? getFarcasterFollowings({ fid })
                    : Promise.resolve(undefined),
                features.includes(Features.FARCASTER_FOLLOWERS)
                    ? getFarcasterFollowers({ fid })
                    : Promise.resolve(undefined),
                features.includes(Features.FARCASTER_CHANNELS)
                    ? getFarcasterChannelsByParticipant({ fid })
                    : Promise.resolve(undefined),
                features.includes(Features.FARCASTER_CASTS)
                    ? getFarcasterUserCasts({ fid })
                    : Promise.resolve(undefined),
            ]);
            if (userDetailsResponse) {
                farcasterRes = Object.assign(Object.assign({}, farcasterRes), { userDetails: userDetailsResponse.data });
            }
            if (farcasterFollowingsResponse) {
                farcasterRes = Object.assign(Object.assign({}, farcasterRes), { farcasterFollowings: farcasterFollowingsResponse.data });
            }
            if (farcasterFollowersResponse) {
                farcasterRes = Object.assign(Object.assign({}, farcasterRes), { farcasterFollowers: farcasterFollowersResponse.data });
            }
            if (farcasterChannelsResponse) {
                farcasterRes = Object.assign(Object.assign({}, farcasterRes), { farcasterChannels: farcasterChannelsResponse.data });
            }
            if (farcasterCastsResponse) {
                farcasterRes = Object.assign(Object.assign({}, farcasterRes), { farcasterCasts: farcasterCastsResponse.data });
            }
            return next(farcasterRes);
        }
        catch (error) {
            throw new Error(JSON.stringify(error));
        }
    };
};
//# sourceMappingURL=farcasterData.js.map