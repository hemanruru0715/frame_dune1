import { useWriteContracts as useWriteContracts$1 } from 'wagmi/experimental';
import { METHOD_NOT_SUPPORTED_ERROR_SUBSTRING, GENERIC_ERROR_MESSAGE, WRITE_CONTRACTS_ERROR_CODE, UNCAUGHT_WRITE_CONTRACTS_ERROR_CODE } from '../constants.js';

/**
 * useWriteContracts: Experimental Wagmi hook for batching transactions.
 * Supports Smart Wallets.
 * Supports batch operations and capabilities such as paymasters.
 * Does not support EOAs.
 */
function useWriteContracts({
  onError,
  setErrorMessage,
  setTransactionId
}) {
  try {
    const _useWriteContracts$ = useWriteContracts$1({
        mutation: {
          onSettled(data, error, variables, context) {
            console.log('settled', data, error, variables, context);
          },
          onError: e => {
            // Ignore EOA-specific error to fallback to writeContract
            if (e.message.includes(METHOD_NOT_SUPPORTED_ERROR_SUBSTRING)) {
              return;
            }
            if (e?.cause?.name === 'UserRejectedRequestError') {
              setErrorMessage('Request denied.');
            } else {
              setErrorMessage(GENERIC_ERROR_MESSAGE);
            }
            onError?.({
              code: WRITE_CONTRACTS_ERROR_CODE,
              error: e.message
            });
          },
          onSuccess: id => {
            setTransactionId(id);
          }
        }
      }),
      status = _useWriteContracts$.status,
      writeContractsAsync = _useWriteContracts$.writeContractsAsync;
    return {
      status,
      writeContractsAsync
    };
  } catch (err) {
    onError?.({
      code: UNCAUGHT_WRITE_CONTRACTS_ERROR_CODE,
      error: JSON.stringify(err)
    });
    setErrorMessage(GENERIC_ERROR_MESSAGE);
    return {
      status: 'error',
      writeContracts: () => {},
      writeContractsAsync: () => Promise.resolve({})
    };
  }
}
export { useWriteContracts };
//# sourceMappingURL=useWriteContracts.js.map
