function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
import { useMemo, createContext, useContext, useState, useCallback } from 'react';
import { useSendTransaction, useConfig } from 'wagmi';
import { formatTokenAmount } from '../../internal/utils/formatTokenAmount.js';
import { USER_REJECTED_ERROR_CODE } from '../constants.js';
import { useFromTo } from '../hooks/useFromTo.js';
import { buildSwapTransaction } from '../utils/buildSwapTransaction.js';
import { getSwapQuote } from '../utils/getSwapQuote.js';
import { isSwapError } from '../utils/isSwapError.js';
import { processSwapTransaction } from '../utils/processSwapTransaction.js';
import { jsx } from 'react/jsx-runtime';
function useValue(object) {
  return useMemo(() => object, [object]);
}
const emptyContext = {};
const SwapContext = /*#__PURE__*/createContext(emptyContext);
function useSwapContext() {
  const context = useContext(SwapContext);
  if (context === emptyContext) {
    throw new Error('useSwapContext must be used within a Swap component');
  }
  return context;
}
function SwapProvider({
  address,
  children,
  experimental
}) {
  // Feature flags
  const useAggregator = experimental.useAggregator;
  const _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    loading = _useState2[0],
    setLoading = _useState2[1];
  const _useState3 = useState(false),
    _useState4 = _slicedToArray(_useState3, 2),
    isTransactionPending = _useState4[0],
    setPendingTransaction = _useState4[1];
  const _useState5 = useState(),
    _useState6 = _slicedToArray(_useState5, 2),
    error = _useState6[0],
    setError = _useState6[1];
  const handleError = useCallback(e => {
    setError(_objectSpread(_objectSpread({}, error), e));
  }, [error]);
  const _useFromTo = useFromTo(address),
    from = _useFromTo.from,
    to = _useFromTo.to;

  // For sending the swap transaction (and approval, if applicable)
  const _useSendTransaction = useSendTransaction(),
    sendTransactionAsync = _useSendTransaction.sendTransactionAsync;

  // Wagmi config, used for waitForTransactionReceipt
  const config = useConfig();

  /* istanbul ignore next */
  const handleToggle = useCallback(() => {
    from.setAmount(to.amount);
    to.setAmount(from.amount);
    from.setToken(to.token);
    to.setToken(from.token);
  }, [from, to]);
  const handleAmountChange = useCallback(async (type, amount, sToken, dToken) => {
    const source = type === 'from' ? from : to;
    const destination = type === 'from' ? to : from;
    source.token = sToken ?? source.token;
    destination.token = dToken ?? destination.token;
    if (source.token === undefined || destination.token === undefined) {
      return;
    }
    if (amount === '' || Number.parseFloat(amount) === 0) {
      return destination.setAmount('');
    }

    // When toAmount changes we fetch quote for fromAmount
    // so set isFromQuoteLoading to true
    destination.setLoading(true);
    handleError({
      quoteError: undefined
    });
    try {
      const response = await getSwapQuote({
        amount,
        amountReference: 'from',
        from: source.token,
        to: destination.token,
        maxSlippage: experimental.maxSlippage?.toString(),
        useAggregator
      });
      // If request resolves to error response set the quoteError
      // property of error state to the SwapError response */
      if (isSwapError(response)) {
        return handleError({
          quoteError: response
        });
      }
      const formattedAmount = formatTokenAmount(response.toAmount, response?.to?.decimals);
      destination.setAmount(formattedAmount);
    } catch (err) {
      handleError({
        quoteError: err
      });
    } finally {
      // reset loading state when quote request resolves
      destination.setLoading(false);
    }
  }, [from, to, useAggregator, handleError, experimental.maxSlippage]);
  const handleSubmit = useCallback(
  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: TODO Refactor this component
  async function handleSubmit(onError, onStart, onSuccess) {
    if (!address || !from.token || !to.token || !from.amount) {
      return;
    }
    setLoading(true);
    handleError({
      swapError: undefined
    });
    try {
      const response = await buildSwapTransaction({
        amount: from.amount,
        fromAddress: address,
        from: from.token,
        to: to.token,
        useAggregator,
        maxSlippage: experimental.maxSlippage?.toString()
      });
      if (isSwapError(response)) {
        return handleError({
          swapError: response
        });
      }
      await processSwapTransaction({
        swapTransaction: response,
        config,
        setPendingTransaction,
        setLoading,
        sendTransactionAsync,
        onStart,
        onSuccess
      });

      // TODO: refresh balances
    } catch (e) {
      const userRejected = e.message.includes('User rejected the request.');
      if (userRejected) {
        setLoading(false);
        setPendingTransaction(false);
        handleError({
          swapError: {
            code: USER_REJECTED_ERROR_CODE,
            error: 'User rejected the request.'
          }
        });
      } else {
        onError?.(e);
        handleError({
          swapError: e
        });
      }
    } finally {
      setLoading(false);
    }
  }, [address, config, handleError, from.amount, from.token, sendTransactionAsync, to.token, useAggregator, experimental.maxSlippage]);
  const value = useValue({
    to,
    from,
    error,
    loading,
    isTransactionPending,
    handleAmountChange,
    handleToggle,
    handleSubmit
  });
  return /*#__PURE__*/jsx(SwapContext.Provider, {
    value: value,
    children: children
  });
}
export { SwapContext, SwapProvider, useSwapContext };
//# sourceMappingURL=SwapProvider.js.map
